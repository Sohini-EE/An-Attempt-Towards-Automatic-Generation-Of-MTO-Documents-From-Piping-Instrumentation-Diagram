# -*- coding: utf-8 -*-
"""PID_symboldetection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fGf9W9zJ0lAIVQylKR4KZ0rXc4Y5OiOo
"""

from google.colab import drive
drive.mount('/content/drive')

folder_path = '/content/drive/My Drive/pid_final/'
!ls "{folder_path}"

!pip install ultralytics

!yolo detect train data=/content/drive/MyDrive/pid_final/dataset.yaml model=yolo11l.pt epochs=100 imgsz=640

#RUN THE CODE IF IMAGE SIZE IS NOT 1280x1280

import cv2
import numpy as np
from PIL import Image
from ultralytics import YOLO
from typing import Tuple
from google.colab.patches import cv2_imshow
import os


def pad_image_to_multiple_of_1280(image: Image.Image) -> Tuple[Image.Image, Tuple[int, int]]:
    """Pad the image with white (255) pixels to make dimensions a multiple of 1280."""
    width, height = image.size
    new_width = ((width + 1279) // 1280) * 1280
    new_height = ((height + 1279) // 1280) * 1280

    padded_image = Image.new("RGB", (new_width, new_height), (255, 255, 255))
    padded_image.paste(image, (0, 0))

    return padded_image, (width, height)


def slice_image_fixed_size(image: Image.Image, tile_size: int = 1280):
    width, height = image.size
    slices = []

    for y in range(0, height, tile_size):
        for x in range(0, width, tile_size):
            crop = image.crop((x, y, x + tile_size, y + tile_size))
            slices.append(((x, y), crop))

    return slices


def detect_on_slices(model, slices, orig_image_size):
    """Run detection on each slice and map boxes back to original coordinates."""
    bboxes, confs, class_ids = [], [], []

    for (x_offset, y_offset), img_tile in slices:
        img_np = np.array(img_tile)
        results = model.predict(img_np, conf=0.25, verbose=False)

        for result in results:
            boxes = result.boxes
            if boxes is None or boxes.xyxy.shape[0] == 0:
                continue

            for i in range(len(boxes.xyxy)):
                x1, y1, x2, y2 = boxes.xyxy[i].cpu().numpy()
                conf = boxes.conf[i].cpu().item()
                class_id = boxes.cls[i].cpu().item()

                # Offset bounding box by tile position
                x1 += x_offset
                x2 += x_offset
                y1 += y_offset
                y2 += y_offset

                bboxes.append([int(x1), int(y1), int(x2), int(y2)])
                confs.append(conf)
                class_ids.append(int(class_id))

    return bboxes, confs, class_ids



def draw_detections(image_np, bboxes, confs, class_ids, class_names):
    for i in range(len(bboxes)):
        x1, y1, x2, y2 = bboxes[i]
        conf = confs[i]
        cls_id = class_ids[i]

        label = f"{class_names[cls_id]} {conf:.2f}"

        cv2.rectangle(image_np, (x1, y1), (x2, y2), (0, 255, 0), 2)
        cv2.putText(image_np, label, (x1, y1 - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)


def main(image_path: str, model_path: str):
    # Load original image
    image = Image.open(image_path).convert("RGB")
    padded_image, (orig_w, orig_h) = pad_image_to_multiple_of_1280(image)

    # Slice into 1280x1280
    slices = slice_image_fixed_size(padded_image, 1280)

    # Load YOLO model
    model = YOLO(model_path)

    # Detect
    bboxes, confs, class_ids = detect_on_slices(model, slices, padded_image.size)

    # Draw detections on the padded image
    orig_np = np.array(padded_image)
    draw_detections(orig_np, bboxes, confs, class_ids, model.names)

    # Save result
    save_path = "stitched_detection.jpg"
    cv2.imwrite(save_path, orig_np)
    print(f"[INFO] Saved result: {save_path}")

    # Show in Colab
    cv2_imshow(orig_np)

    return class_ids, confs, model_path
# Run main
if __name__ == "__main__":
    #use image path and model path of your own image and model
    image_path = "/content/P&ID..._page-0001.jpg"
    model_path = "/content/runs/detect/train2/weights/best.pt"
    main(image_path, model_path)

import pandas as pd
from collections import Counter


def write_detection_summary(class_ids, class_names, output_path="detection_summary.csv"):
    # Count how many times each class_id appears
    class_counts = Counter(class_ids)

    # Build a summary list
    summary = [{
        "class_name": class_names[cls_id],
        "count": count
    } for cls_id, count in class_counts.items()]

    # Save as CSV
    df = pd.DataFrame(summary)
    df.to_csv(output_path, index=False)
    print(f"[INFO] Saved detection summary to {output_path}")


class_ids, confs, class_names = main(image_path, model_path)
write_detection_summary(class_ids, class_names)

#Detection of 1280x1280 image and representing them in a csv file

from ultralytics import YOLO
import pandas as pd
from collections import Counter
import numpy as np

# Load model
model_path = "/content/best.pt"
model = YOLO(model_path)

# Define image path
image_path = "/content/1.jpeg"

# Run object detection
results = model(image_path, save=True)



# Extract detection results
result = results[0]
boxes = result.boxes

# Extract class IDs and confidences
class_ids = boxes.cls.cpu().numpy().astype(int).tolist()
confs = boxes.conf.cpu().numpy().tolist()
class_names = model.names  # This is a dict like {0: 'A', 1: 'B', ...}


# Function to write summary to CSV
def write_detection_summary(class_ids, class_names, output_path="detection_summary.csv"):
    class_counts = Counter(class_ids)

    summary = [{
        "class_name": class_names[cls_id],
        "count": count
    } for cls_id, count in class_counts.items()]

    df = pd.DataFrame(summary)
    df.to_csv(output_path, index=False)
    print(f"[INFO] Saved detection summary to {output_path}")

# Call the function
write_detection_summary(class_ids, class_names)